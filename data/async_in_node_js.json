{
    "_id": "7a2a5dc340e7dd5f6e7439078200256b",
    "published": true,
    "slug": "asynchronous_code_in_node_js",
    "type": "blogpost",
    "title": "Asynchronous code in node.js",
    "pubdate": "Tue, 01 Jun 2010 21:00:00 +0100",
    "intro": "Writing an async library has almost become a right of passage for node\ndevelopers and I really don't want to add to this myriad of already great\nmodules. Really. However (you saw that coming!), when I'm using node, I want\nto stay fairly close to the vanilla async implementation. When writing my own\nmodules I try to follow the convention of using a single callback with an\noptional error as the first argument.",
    "markdown": "Writing an async library has almost become a right of passage for node\ndevelopers and I really don't want to add to this myriad of already great\nmodules. Really. However (you saw that coming!), when I'm using node, I want\nto stay fairly close to the vanilla async implementation. When writing my own\nmodules I try to follow the convention of using a single callback with an\noptional error as the first argument.\n\nFor people not familiar with the various async implementations, below is an\nexample function implemented in a few of the options available.\n\n### Single callback (as used in the standard node modules)\n\n<pre><code class=\"javascript\">// defining a function\nvar async_function = function(val, callback){\n    process.nextTick(function(){\n        callback(val);\n    });\n};\n\n// using the function\nasync_function(true, function(val){\n    // val == true\n});</code></pre>\n\n### Continuations (as provided by the node-continuables module by bentomas)\n\n<pre><code class=\"javascript\">var continuables = require('continuables');\n\n// defining a function\nvar async_function = function(val){\n    var continuable = continuables.create();\n    process.nextTick(function(){\n        continuable.fulfill(val);\n    });\n    return continuable;\n};\n\n// using the function\nasync_function(true)\n(function(val) {\n    // val == true\n});</code></pre>\n\n### Promises (as provided by the node-promise module by kriszyp)\n\n<pre><code class=\"javascript\">var Promise = require(\"promise\").Promise;\n\n// defining a function\nvar async_function = function(val){\n    var promise = new Promise();\n    process.nextTick(function(){\n        Promise.resolve(\"succesful result\");\n    });\n    return promise;\n};\n\n// using the function\nvar promise = async_function(true);\npromise.then(function(val){\n    // val == true\n},\nfunction(error){\n    // executed if the promise fails\n});</code></pre>\n\nWhile these new styles provide some interesting capabilities, sticking to\nconvention makes the API easier to understand, and allows people to wrap the\nmodule with other methods of handling async code if they so wish.\n\nBecause of this, I've avoided using these existing async modules in favour\nof the single callback style used throughout node. However, I've found myself\nrepeating a number of patterns, so I've decided to abstract the more\ncommon ones into a separate module. And so, the\n[async](http://github.com/caolan/async) module was born! Aha! I hear you say.\nNow you too are implementing a new way of doing async!  ...Well, not quite.\n\nWhat I've ended up with are a few higher-order functions that operate on async\ncode using the convention of a single callback. This includes the usual\n'functional' suspects (map, reduce, filter, forEach...) as well as some common\npatterns for running blocks of async code (parallel, series, waterfall,\nauto...).\n\nThis is not an entirely new idea. Perhaps the closest existing module is\n[Do](http://howtonode.org/do-it-fast) by creationix. However, Do operates on\ncontinuations, not on functions using the standard callbacks. This means you\nhave to wrap any functions using the conventional style before using them\nwith Do:\n\n<pre><code class=\"javascript\">var Do = require('do');\n// Convert `readFile` from fs to use continuable style.\nvar fs = Do.convert(require('fs'), ['readFile']);</code></pre>\n\nSo, in case you didn't get it already: __the async module is not an attempt to\nreplace the standard callback mechanism in node__. It is designed to work as\nseamlessly as possible with the existing node modules by working with functions\nusing the single callback style.\n\nI think I have now compiled the most comprehensive set of features for working\nwith async functions in node. It includes many of the ideas from other modules,\nsuch as Do, and wouldn't have been possible without the great work that's gone\ninto them.\n\nIf you're interested, you can check out the code on\n[Github](http://github.com/caolan/async). Alteratively, see below for example\nusage and a quick explanation of the functions available.\n\n\n## Example\n\nJust for fun, here is an example of using one of the higher-order async\nfunctions. This example tests a list of filenames and reports any files that\nalready exist.\n\n### With the async module\n\n<pre><code class=\"javascript\">var files = ['file1', 'file2', 'file3'];\n\nasync.filter(files, path.exists, function(results){\n    if(results) sys.puts('The following files already exist: ' + results);\n});</code></pre>\n\n\n### Without the async module\n\n<pre><code class=\"javascript\">var files = ['file1', 'file2', 'file3'],\n    results = [],\n    completed = 0;\n\nfiles.forEach(function(f){\n    path.exists(f, function(exists){\n        if(exists) results.push(f);\n        completed++;\n        if(completed == files.length){\n            if(results){\n                sys.puts('The following files already exist: ' + results);\n            }\n        }\n    });\n});</code></pre>\n\n\n## API\n\n### Collections\n\n* __forEach (forEachSeries)__ - Applies an async iterator to each item in an\narray.\n* __map (mapSeries)__ - Produces a new array of values by mapping each value\nin the given array through an async iterator function.\n* __filter (filterSeries)__ - Returns a new array of all the values which pass\nan async truth test.\n* __reduce__ - Reduces a list of values into a single value using an async\niterator to return each successive step.\n* __some__ - Returns true if at least one element in the array satisfies an\nasync test.\n* __every__ - Returns true if evert element in the array satisfies an async\ntest.\n\n### Flow Control\n\n* __series__ - Run an array of functions in series, each one running once the\nprevious function has completed.\n* __parallel__ - Run an array of functions in parallel, without waiting until\nthe previous function has completed.\n* __waterfall__ - Runs an array of functions in series, each passing their\nresults to the next in the array.\n* __auto__ - Determines the best order for running functions based on their\nrequirements.\n* __iterator__ - Creates an iterator function which calls the next function in\nthe array, returning a continuation to call the next one after that.\n\n\n[Get the code!](http://github.com/caolan/async)\n"
}
