{
    "_id": "b2d7560775b54b86543c376b0f005f70",
    "published": true,
    "type": "blogpost",
    "pubdate": "Fri, 17 Jul 2009 23:27:19 +0100",
    "title": "Flatten for Python",
    "slug": "flatten_for_python",
    "intro": "After making frequent use of __lists:flatten/1__ in Erlang, I found myself wanting to use this function in Python too. Somewhat surprisingly, Python doesn't have a builtin for flattening lists. If you're not familiar with flatten, its most easily explained through some quick examples:",
    "markdown": "After making frequent use of __lists:flatten/1__ in Erlang, I found myself wanting to use this function in Python too. Somewhat surprisingly, Python doesn't have a builtin for flattening lists. If you're not familiar with flatten, its most easily explained through some quick examples:\n\n<pre><code class=\"no-highlight\">&gt;&gt;&gt; flattened([1,2,3,4])\n[1,2,3,4]\n&gt;&gt;&gt; flattened([[1,2],[3,4]])\n[1,2,3,4]\n&gt;&gt;&gt; flattened([[[[1],2],3],4]])\n[1,2,3,4]</code></pre>\n\nHopefully you get the idea, it takes nested lists and places all the items they contain in order into a single list. My initial hack to get this working was the following one-liner:\n\n<pre><code class=\"python\">def flattened(l):\n    return reduce(lambda x,y: x+[y] if type(y) != list else x+flatten(y), l,[])</code></pre>\n\nThis was fine in the scenario I'd written it for, but I knew full-well it was going to explode with recursion errors if it ever encountered a long, complicated list. Unlike Erlang, Python doesn't do nice tail recursion, and will fall over when its call stack fills up, reporting a RuntimeError.\n\nRecently, I came across this snippet of code again and decided to solve the problem properly. After some Googling around I found [this](http://aspn.activestate.com/ASPN/Mail/Message/python-tutor/2302231) post by Danny Yoo on a [Continuation Passing Style](http://en.wikipedia.org/wiki/Continuation-passing_style) version of flatten. This got the geek in me all interested, and I decided to see if I could write something in the form of a Python generator instead, while still avoiding the maximum recursion depth issue. Here is the resulting code (seriously nasty code coming up!):\n\n<pre><code class=\"python\">def flattened(l):\n    result = _flatten(l, lambda x: x)\n    while type(result) == list and len(result) and callable(result[0]):\n        if result[1] != []:\n            yield result[1]\n        result = result[0]([])\n    yield result\n\ndef _flatten(l, fn, val=[]):\n    if type(l) != list:\n        return fn(l)\n    if len(l) == 0:\n        return fn(val)\n     return [lambda x: _flatten(l[0], lambda y: _flatten(l[1:],fn,y), x), val]</code></pre>\n\nApart from making my brain hurt, what really amazed me about this approach was the _speed increases_. On a list nested to a depth of 100, this turned out to be around __2 times faster__ than the the CPS version by Danny Yoo. However, this is not a linear relationship, at a depth of 20,000 it was completing around __12 times faster__ (and yes, thats generating the whole list, not the time taken to hit the first yield). I didn't expect there to be such a difference, but I'm now interested in seeing where else generators and this kind of pattern can be used!\n\n__Note:__ I decided to rename the function 'flattened', because of its similarity to the Python builtin 'reversed' which returns a new generator instead of editing the list in place. This function also only flattens lists, not tuples (intentionally), if you wanted it to flatten tuples it should only require some slight tweaking (which I'll leave to you)."
}
