{
    "_id": "133e06eaff0bc1eee8e394d866000a5f",
    "published": true,
    "type": "blogpost",
    "pubdate": "Tue, 18 Jan 2011 09:00:00 GMT",
    "title": "CommonJS modules in CouchDB",
    "slug": "commonjs_modules_in_couchdb",
    "oldurl": "/commonjs_in_couchdb.html",
    "intro": "You may not realise that [CouchDB](http://couchdb.org) actually\n[supports](http://wiki.apache.org/couchdb/CommonJS_Modules)\n[CommonJS modules](http://wiki.commonjs.org/wiki/Modules) in design documents.\nThis can be very useful when you want to share code across different list,\nshow, update or validation functions.",
    "markdown": "You may not realise that [CouchDB](http://couchdb.org) actually\n[supports](http://wiki.apache.org/couchdb/CommonJS_Modules)\n[CommonJS modules](http://wiki.commonjs.org/wiki/Modules) in design documents.\nThis can be very useful when you want to share code across different list,\nshow, update or validation functions.\n\nIts also a useful way to share code between the client and server by\nusing a CommonJS implementation for the browser. Normally you would store\nclient-side code in an attachment, but by storing it on the design doc you\ncan access it server-side too!\n\nCommonJS modules are a neat way to write JavaScript which doesn't pollute\nthe global namespace. If you're used to using a server-side JavaScript\nplatform (such as node.js) you'll be familiar with the advantages, and may\neven be able to re-use a few modules.\n\n\n## Adding a CommonJS module\n\nTo add a module to a design document you need to store it as a string (much\nas you would for any other function). Modules can be stored under any property\nname:\n\n<pre><code class=\"javascript\">{\n    \"_id\": \"_design/example\",\n    \"lib\": {\n        \"mymodule\": \"exports.name = 'my module';\"\n    },\n    \"mymodule2\": \"exports.name = 'my module 1';\"\n}</code></pre>\n\nYou'll notice that modules can be stored under a hierachy of properties.\nThe above design document would allow you to require 'lib/mymodule' or\n'mymodule2'.\n\n\n## CouchDB's require\n\nPaths are from the root of the design doc, unless explicitly relative.\nRelative paths start with '..' or '.' and are relative to the current module.\nSo, from 'lib/mymodule' in the previous example, you could\ndo require('../mymodule1').\n\nLet's make the example design doc a little more confusing!\n\n<pre><code class=\"javascript\">{\n    \"_id\": \"_design/example\",\n    \"lib\": {\n        \"mymodule\": \"exports.name = 'my module 1';\"\n        \"mymodule2\": \"exports.name = 'new module';\"\n    },\n    \"mymodule2\": \"exports.name = 'my module 2';\"\n}</code></pre>\n\nNow, if from 'lib/mymodule' we were to do require('mymodule2').name, what\nvalue would be returned? In this case it would be 'my module 2', not\n'new module', since the path is not _explicitly_ relative.\n\nYou cannot require modules from another design document. This is as you\nwould expect from CouchDB.\n\n\n## View functions\n\nYou can't require modules from within view (map/reduce) functions.\nThis is because CouchDB needs to know when the behaviour of a view changes,\nso it can rebuild the list of results.\n\n__However__, in the upcoming CouchDB 1.1.x views will be able to require\nmodules provided they exist below the 'views' property (eg, 'views/lib/module'):\n\n<pre><code class=\"javascript\">{\n    \"_id\": \"_design/example\",\n    \"lib\": {\n        // modules here would not be accessible from view functions\n    },\n    \"views\": {\n        \"lib\" {\n            // this module is accessible from view functions\n            \"module\": \"exports.test = 'asdf';\"\n        },\n        \"commonjs\": {\n            \"map\": function (doc) {\n                var val = require('views/lib/module').test;\n                emit(doc._id, val);\n            }\n        }\n    }\n}</code></pre>\n\n\n## Module caching\n\nCurrently, CouchDB does not support caching of eval'd modules. That means\nrequiring a complex module evaluates it every time. This is obviously\nquite inefficient, and there is an\n[ticket in JIRA](https://issues.apache.org/jira/browse/COUCHDB-890) to fix this.\n\nOne additional problem with not having a module cache is that modules cannot\nstore state between requires. This technique can sometimes be used to cache function\nresults, or to store a registry of templates or settings. Be careful when using\nlibraries that depend on this.\n\n\n## Exactly which spec does CouchDB implement?\n\nCouchDB initially implemented\n[Modules 1.0](http://wiki.commonjs.org/wiki/Modules/1.0) in the 0.11.0 release.\nThis was later upgraded to\n[Modules 1.1.1](http://wiki.commonjs.org/wiki/Modules/1.1.1) in version 0.11.1.\n\nModules 1.1.1 was developed by Mikeal and the CommonJS team to overcome some\nproblems that made [Modules 1.1](http://wiki.commonjs.org/wiki/Modules/1.1)\ndifficult to implement in CouchDB.\n\n### module.exports\n\nUsing module.exports to change the exported object entirely can be quite useful,\nbut was not added until after the Modules 1.0 spec. That means any code which\nrequires this will not run on CouchDB 0.11.0 or earlier!\n\nFor example, using module.exports, you could have a commonjs module export a\nstring instead of an object:\n\n<pre><code class=\"javascript\">{\n    \"module1\": \"module.exports = 'test';\"\n    \"module2\": \"val val = require('module1'); // val is now equal to 'test'\n}</code></pre>\n\n\n## Going further\n\nIf you've found this interesting or useful, you might want to follow the progress\nof my experiments on pushing the module system further at\n<a href=\"http://kansojs.org\">kansojs.org</a>."
}
