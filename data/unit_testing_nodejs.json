{
    "_id": "a21b038ac7938c45ea910e43c3000059",
    "published": true,
    "type": "blogpost",
    "pubdate": "Mon, 20 Sep 2010 21:45:00 +0100",
    "title": "Unit testing in node.js",
    "slug": "unit_testing_in_node_js",
    "intro": "Node.js provides a its own [assert module](http://nodejs.org/api.html#assert-280) with some really useful functions for creating basic tests. However, the reporting and running of these assertions can become complicated, especially with asynchronous code. How can you be sure that all assertions ran? Or that they ran in the correct order? This is where nodeunit comes in, a tool for defining and running unit tests in the simplest way possible.",
    "markdown": "Node.js provides a its own [assert module](http://nodejs.org/api.html#assert-280) with some really useful functions for creating basic tests. However, the reporting and running of these assertions can become complicated, especially with asynchronous code. How can you be sure that all assertions ran? Or that they ran in the correct order? This is where nodeunit comes in, a tool for defining and running unit tests in the simplest way possible.\n\nLets walk through a basic node.js program using Test Driven Developement (TDD) and nodeunit. This program asks the user to enter a number, doubles it and returns the result.\n\n## Installing nodeunit\n\nFirst of all, [download nodeunit](http://github.com/caolan/nodeunit/downloads). If\nyou want to use the absolute latest version you can clone from the\n[github repository](http://github.com/caolan/nodeunit).\n\nOnce downloaded, extract the files, cd to the directory and run:\n\n    make && sudo make install\n\nIf you have [npm](http://github.com/isaacs/npm) installed, you can install by doing:\n\n    npm install nodeunit\n\n\n## Writing our first unit test\n\nCreate a project directory and cd into it. Let's call this project 'doubled':\n\n    mkdir doubled\n    cd doubled\n\nLet's also make a directory for our unit tests, by convention (and the\n[commonjs specs](http://wiki.commonjs.org/wiki/Packages/1.0#Package_Directory_Layout)\n,\nthis is called 'test':\n\n    mkdir test\n\nNow, create the file test-doubled.js in the test directory, and add the following:\n\n<pre><code class=\"javascript\">var doubled = require('../lib/doubled');\n\nexports['calculate'] = function (test) {\n    test.equal(doubled.calculate(2), 4);\n    test.done();\n};</code></pre>\n\nSay hello to our first unit test! So, what's going on here? First, we import our\n(non-existent) module 'doubled'. We then export a function called 'calculate'.\nNodeunit will run any exported functions as unit tests.\n\nThe test function accepts one argument, which is the test object. The test object\ncontains all the assert module methods plus two new methods: 'expect' and 'done'.\nExpect can be used to tell nodeunit how many assertions you expect to run (we'll\ncome to this later), and the done function tells nodeunit that the test has\ncompleted. Explicitly ending your unit tests is important when testing async code.\nOtherwise, its easy for callbacks not to fire, and for a test to end without all the\nassertions being run.\n\nInside our test, we call a function from the doubled module called\n'calculate'. This was simply chosen because it seemed like a good starting point.\nNow, let's try running our test. From your project directory run:\n\n    nodeunit test\n\nThis tells nodeunit to run all the modules in the test directory. This should\noutput something similar to the following:\n\n![Screen 1]({baseURL}/static/nodeunit_tutorial/screen1.png)\n\nI suppose we better add that doubled module then. Create a 'lib' folder in the\nproject directory and add a doubled.js file containing the following:\n\n<pre><code class=\"javascript\">exports.calculate = function (num) {\n    return num * 2;\n};</code></pre>\n\nNow, run the tests again:\n\n![Screen 2]({baseURL}/static/nodeunit_tutorial/screen2.png)\n\nMuch better. Now, let's say we want the function to throw an error if the argument\nis not a number. Time to revisit our unit test:\n\n<pre><code class=\"javascript\">var doubled = require('../lib/doubled');\n\nexports['calculate'] = function (test) {\n    test.equal(doubled.calculate(2), 4);\n    test.equal(doubled.calculate(5), 10);\n    test.throws(function () { doubled.calculate(); });\n    test.throws(function () { doubled.calculate(null); });\n    test.throws(function () { doubled.calculate(true); });\n    test.throws(function () { doubled.calculate([]); });\n    test.throws(function () { doubled.calculate({}); });\n    test.throws(function () { doubled.calculate('asdf'); });\n    test.throws(function () { doubled.calculate('123'); });\n    test.done();\n};</code></pre>\n\nThat looks fairly all-encompassing, time to run the tests again:\n\n![Screen 3]({baseURL}/static/nodeunit_tutorial/screen3.png)\n\nTime to update our module in the familiar cycle of Test Driven Development:\n\n<pre><code class=\"javascript\">exports.calculate = function (num) {\n    if (typeof num === 'number') {\n         return num * 2;\n    }\n    else {\n        throw new Error('Expected a number');\n    }\n};</code></pre>\n\nRun the tests again:\n\n![Screen 4]({baseURL}/static/nodeunit_tutorial/screen4.png)\n\nSuccess! We've now completed a basic unit test and written a module that satisfies\nit. Time to move onto something a little more challenging and look at reading user\ninput.\n\n\n## Testing asynchronous code\n\nNext, we'll create a test for the 'read' function. This function should read a\nvalue from stdin, and call process.exit when complete:\n\n<pre><code class=\"javascript\">exports['read a number'] = function (test) {\n    var ev = new events.EventEmitter();\n\n    process.openStdin = function () { return ev; };\n    process.exit = test.done;\n\n    doubled.read();\n    ev.emit('data', '12');\n};</code></pre>\n\nThis test does something JavaScript is very nice for, stubs and mock objects!\nFirstly, stdin is an EventEmitter, so we create our own EventEmitter object and\noverride process.openStdin to return it. Next we override process.exit with the\ntest.done function, so this test will only complete successfully if the read\nfunction calls process.exit. Next, we call the read function we're testing. This\nshould wait for stdin to emit a 'data' event before doing anything. This is where\nour custom EventEmitter comes in handy. Now, we can use it to emit data events to\nsimulate a user entering input.\n\nRun the tests:\n\n![Screen 5]({baseURL}/static/nodeunit_tutorial/screen5.png)\n\nTime to add the read function, which should open stdin, wait for data, then call\nprocess.exit:\n\n<pre><code class=\"javascript\">exports.read = function () {\n    var stdin = process.openStdin();\n\n    stdin.on('data', function (chunk) {\n        process.exit();\n    });\n};</code></pre>\n\nTry again:\n\n![Screen 6]({baseURL}/static/nodeunit_tutorial/screen6.png)\n\nSuccess! But wait, we've forgotten to do anything with the data (in fact, the read\nfunction could just be calling process.exit and still pass). We want this function to\noutput the doubled number using console.log. Time to revisit the tests:\n\n<pre><code class=\"javascript\">exports['read a number'] = function (test) {\n    var ev = new events.EventEmitter();\n\n    process.openStdin = function () { return ev; };\n    process.exit = test.done;\n\n    console.log = function (str) {\n        test.equal(str, 'doubled: 24');\n    };\n\n    doubled.read();\n    ev.emit('data', '12');\n};</code></pre>\n\nOK, we're now testing for output using console.log. Run the tests!\n\n![Screen 7]({baseURL}/static/nodeunit_tutorial/screen7.png)\n\nHmm, that should have failed. We've fallen for a normal problem with unit testing,\nthat is especially important to watch out for when testing asynchronous code. The\nconsole.log function is never called, so our 'equal' assertion never runs. What we\nneed to do is assert that all our assertions run! Thankfully, nodeunit provides an\neasy way to catch this problem in most situations: the expect method. Using the\nexpect method tells nodeunit how many assertions should have run in your test. Lets\nupdate our test function to include it:\n\n<pre><code class=\"javascript\">exports['read a number'] = function (test) {\n    test.expect(1);\n    var ev = new events.EventEmitter();\n\n    process.openStdin = function () { return ev; };\n    process.exit = test.done;\n\n    console.log = function (str) {\n        test.equal(str, 'doubled: 24');\n    };\n\n    doubled.read();\n    ev.emit('data', '12');\n};</code></pre>\n\nNow, when you run your test, it should fail:\n\n![Screen 8]({baseURL}/static/nodeunit_tutorial/screen8.png)\n\nGreat, let's update the read function so that it passes:\n\n<pre><code class=\"javascript\">exports.read = function () {\n    var stdin = process.openStdin();\n\n    stdin.on('data', function (chunk) {\n        var num = parseFloat(chunk);\n        var result = exports.calculate(num);\n        console.log('doubled: ' + result);\n        process.exit();\n    });\n};</code></pre>\n\n![Screen 9]({baseURL}/static/nodeunit_tutorial/screen9.png)\n\n\n## Shared state and sequential testing\n\nCurrently our read function seems to work with the expected input data. But what\nshould happen if the user enters a value other than a number? Let's write another\ntest that checks that any errors which occur during calculating the result are\ndisplayed to the user. Here is the full test-doubled.js file after adding this test:\n\n<pre><code class=\"javascript\">var doubled = require('../lib/doubled'),\n    events = require('events');\n\n\nexports['calculate'] = function (test) {\n    test.equal(doubled.calculate(2), 4);\n    test.equal(doubled.calculate(5), 10);\n    test.throws(function () { doubled.calculate(); });\n    test.throws(function () { doubled.calculate(null); });\n    test.throws(function () { doubled.calculate(true); });\n    test.throws(function () { doubled.calculate([]); });\n    test.throws(function () { doubled.calculate({}); });\n    test.throws(function () { doubled.calculate('asdf'); });\n    test.throws(function () { doubled.calculate('123'); });\n    test.done();\n};\n\nexports['read a value other than a number'] = function (test) {\n    test.expect(1);\n    var ev = new events.EventEmitter();\n    \n    process.openStdin = function () { return ev; };\n    process.exit = test.done;\n    doubled.calculate = function () {\n        throw new Error('Expected a number');\n    };\n    console.log = function (str) {\n        test.equal(str, 'Error: Expected a number');\n    };\n    \n    doubled.read();\n    ev.emit('data', 'asdf');\n};\n\nexports['read a number'] = function (test) {\n    test.expect(1);\n    var ev = new events.EventEmitter();\n\n    process.openStdin = function () { return ev; };\n    process.exit = test.done;\n    console.log = function (str) {\n        test.equal(str, 'doubled: 24');\n    };\n    \n    doubled.read();\n    ev.emit('data', '12');\n};</code></pre>\n\nBe sure to copy the above code into your test-doubled.js file and pay special\nattention to the ordering of the tests. Next, we update lib/doubled.js to catch\nexceptions and report them using console.log:\n\n<pre><code class=\"javascript\">exports.read = function () {\n    var stdin = process.openStdin();\n    \n    stdin.on('data', function (chunk) {\n        var num = parseFloat(chunk);\n        try {\n            var result = exports.calculate(num);\n            console.log('doubled: ' + result);\n        }\n        catch (e) {\n            console.log(e);\n        }\n        process.exit();\n    });\n};</code></pre>\n\nNow, run the tests:\n\n![Screen 10]({baseURL}/static/nodeunit_tutorial/screen10.png)\n\nHmm, this is an odd one. The new test passes, but a previously passing test now\nfails. This is due to our mocking and stubbing in the tests for the read function.\nThe problem is that node.js contains a module cache that will persist our changes\nto process, double and console functions. In the test 'read a value other than a\nnumber' we override double.calculate, but never restore it.\n\nTo fix this, we need to reset all these functions to their original state after\ntesting. We need to be careful that this is done just before we call test.done(),\nto make sure they are not reset part-way through the test!\n\n\n<pre><code class=\"javascript\">exports['read a value other than a number'] = function (test) {\n    test.expect(1);\n    var ev = new events.EventEmitter();\n\n    var _openStdin = process.openStdin;\n    process.openStdin = function () { return ev; };\n    \n    var _exit = process.exit;\n    process.exit = function () {\n        // reset all the overidden functions:\n        process.openStdin = _openStdin;\n        process.exit = _exit;\n        doubled.calculate = _calculate;\n        console.log = _log;\n        \n        test.done();\n    };\n    \n    var _calculate = doubled.calculate;\n    doubled.calculate = function () {\n        throw new Error('Expected a number');\n    };\n    \n    var _log = console.log;\n    console.log = function (str) {\n        test.equal(str, 'Error: Expected a number');\n    };\n    \n    doubled.read();\n    ev.emit('data', 'asdf');\n};\n\nexports['read a number'] = function (test) {\n    test.expect(1);\n    var ev = new events.EventEmitter();\n    \n    var _openStdin = process.openStdin;\n    process.openStdin = function () { return ev; };\n    \n    var _exit = process.exit;\n    process.exit = function () {\n        // reset all the overidden functions:\n        process.openStdin = _openStdin;\n        process.exit = _exit;\n        console.log = _log;\n        \n        test.done();\n    };\n    \n    var _log = console.log;\n    console.log = function (str) {\n        test.equal(str, 'doubled: 24');\n    };\n    \n    doubled.read();\n    ev.emit('data', '12');\n};</code></pre>\n\nPhew! Right, let's try running those tests again:\n\n![Screen 11]({baseURL}/static/nodeunit_tutorial/screen11.png)\n\nThis is also the main reason the nodeunit runs unit tests sequentially, in series.\nOtherwise you wouldn't be able to use any mocks, as functions would be overwriting\neach others mocked functions. Running tests in parallel may be a good idea for\nspeeding up integration tests, but its a bad idea for unit testing!\n\n\n## Test cases, setUp and tearDown\n\n__This section requires you to have nodeunit installed in your path (by copying the\nnodeunit folder to ~/.node_libraries or installing it via npm)__\n\nThere's a few problems with the tests above. Firstly, they repeat code which we'd\nrather write once. Secondly, they're ugly! This can be remedied by using test cases.\nThe nodeunit module exports a function called testCase that helps you to define test\nfunctions that share code regarding their running environment. Let's use testCase\nto tidy up our test functions:\n\n<pre><code class=\"javascript\">var nodeunit = require('nodeunit');\n\n\nexports['read'] = nodeunit.testCase({\n\n    setUp: function () {\n        this._openStdin = process.openStdin;\n        this._log = console.log;\n        this._calculate = doubled.calculate;\n        this._exit = process.exit;\n\n        var ev = this.ev = new events.EventEmitter();\n        process.openStdin = function () { return ev; };\n    },\n    tearDown: function () {\n        // reset all the overidden functions:\n        process.openStdin = this._openStdin;\n        process.exit = this._exit;\n        doubled.calculate = this._calculate;\n        console.log = this._log;\n    },\n\n    'a value other than a number': function (test) {\n        test.expect(1);\n\n        process.exit = test.done;\n        doubled.calculate = function () {\n            throw new Error('Expected a number');\n        };\n        console.log = function (str) {\n            test.equal(str, 'Error: Expected a number');\n        };\n        doubled.read();\n        this.ev.emit('data', 'asdf');\n    },\n\n    'a number': function (test) {\n        test.expect(1);\n\n        process.exit = test.done;\n        console.log = function (str) {\n            test.equal(str, 'doubled: 24');\n        };\n        doubled.read();\n        this.ev.emit('data', '12');\n    }\n\n});</code></pre>\n\nThat looks better. The setUp and tearDown functions share context with the test\nfunction, which means anything you store on the object 'this' will be available\nbetween them. Let's run the tests one more time:\n\n![Screen 12]({baseURL}/static/nodeunit_tutorial/screen12.png)\n\n\n## What next?\n\nHave fun writing unit tests and playing with node.js. For more information on\nnodeunit, see the [README](http://github.com/caolan/nodeunit/blob/master/README.md).\n\nBe sure to [watch nodeunit on github](http://github.com/caolan/nodeunit) for updates!\nYou might also want to check out the development of\n[nodeunit-dsl](http://github.com/gerad/nodeunit-dsl) by gerad, which attempts to\nimplement a 'pretty dsl on top on nodeunit'.\n\nIf you have any problems with this guide, please comment. If you have any problems\nwith nodeunit, please [raise an issue on github](http://github.com/caolan/nodeunit/issues)."
}
