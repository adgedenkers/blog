{
    "_id": "a21b038ac7938c45ea910e43c3000da5",
    "published": true,
    "type": "blogpost",
    "pubdate": "Thu, 01 Jul 2010 20:08:00 GMT",
    "title": "Writing for node and the browser",
    "slug": "writing_for_node_and_the_browser",
    "intro": "Modules that can be used both on the server and the client-side are a useful way to reuse code. This is one way of writing a module that will work well with both systems, while allowing you to write code in the familiar node style.",
    "markdown": "Modules that can be used both on the server and the client-side are a useful\nway to reuse code. This is one way of writing a module that will work well with\nboth systems, while allowing you to write code in the familiar node style.\n\nIn node you use module.exports (or just exports) to expose a function:\n\n<pre><code class=\"javascript\">exports.test = function(){\n    return 'hello world';\n};</code></pre>\n\nHowever, in the browser this will break since 'exports' is not defined. So,\nto work around this, we first need to check if exports is defined, and if not,\ncreate a sensible object for exporting functions to. In the browser this could\nbe a global with the same name as the module:\n\n<pre><code class=\"javascript\">if(typeof exports == 'undefined'){\n    var exports = this['mymodule'] = {};\n}</code></pre>\n\nThe second problem is that anything you define in the module but don't\nexport can become available in the browser:\n\n<pre><code class=\"javascript\">function notExported(){\n    return \"shh, I'm not here\";\n}\n\nexports.test = function(){\n    return 'hello world';\n};</code></pre>\n\nIn the example above, requiring the module in node would return an object with\nthe method test and nothing else, but in the browser this code would create a\nnew global function called notExported. To fix this problem its a good idea to\nwrap the module's code in a closure (this is good practice anyway!).\n\nBelow is an example module that uses a closure which accepts an exports\nobject as an argument. A sensible exports object is created if one does not\nalready exist.\n\n__mymodule.js__\n\n<pre><code class=\"javascript\">(function(exports){\n\n    // your code goes here\n\n   exports.test = function(){\n        return 'hello world'\n    };\n\n})(typeof exports === 'undefined'? this['mymodule']={}: exports);</code></pre>\n\nNote the use of this['mymodule'] as an export location in the browser. This\ncode can now be used both client and server side:\n\n__node__\n\n<pre><code class=\"javascript\">var mymodule = require('./mymodule'),\n    sys = require('sys');\n\nsys.puts(mymodule.test());</code></pre>\n\n__browser__\n\n<pre><code class=\"html\">&lt;script src=\"mymodule.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    alert(mymodule.test());\n&lt;/script&gt;</code></pre>\n\nOf course, the browser doesn't support many other node features like require(),\nso you'll need to test that your code is suitable for use in the browser first.\nAlso, be careful when using code originally written only for node because the\nV8 javascript engine supports newer language features than many browsers."
}
